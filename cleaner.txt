#include <incmode>.
		 
#program base.
#const r=4.
#const c=8.
% Type declarations
% D={u,d,l,r}.
% move(D,T).
row(0..r).
column(0..c).
type(obs;free;goal;initial;actual).
dir(u;d;l;r).
% tile(R,C,T), row(R), column(C), type(T).
available(D,R,C) :- tile(R,C,_), tile(R2,C2,T), R-R2=1, D=up, T!=obs.
available(D,R,C) :- tile(R,C,_), tile(R2,C2,T), R2-R=1, D=down, T!=obs.
available(D,R,C) :- tile(R,C,_), tile(R2,C2,T), C-C2=1, D=left, T!=obs.
available(D,R,C) :- tile(R,C,_), tile(R2,C2,T), C2-C=1, D=right, T!=obs.

% Initial state
tile(1,1,initial).
tile(1,2,free).
tile(1,3,free).
tile(1,4,free).
tile(1,5,free).
tile(1,6,obs).
tile(1,7,obs).
tile(1,8,free).

tile(2,1,free).
tile(2,2,free).
tile(2,3,free).
tile(2,4,free).
tile(2,5,free).
tile(2,6,free).
tile(2,7,free).
tile(2,8,free).

tile(3,1,free).
tile(3,2,free).
tile(3,3,obs).
tile(3,4,obs).
tile(3,5,obs).
tile(3,6,free).
tile(3,7,free).
tile(3,8,free).

tile(4,1,free).
tile(4,2,free).
tile(4,3,free).
tile(4,4,obs).
tile(4,5,obs).
tile(4,6,free).
tile(4,7,free).
tile(4,8,goal).

roomba(R,C,0) :- tile(R,C,initial).

#program step(t).

% Executability axioms

% Effect axioms
roomba(R,C,t) :- roomba(R+1,C,t-1), move(D,t), dir(D), D=u.
roomba(R,C,t) :- roomba(R-1,C,t-1), move(D,t), dir(D), D=d.
roomba(R,C,t) :- roomba(R,C+1,t-1), move(D,t), dir(D), D=l.
roomba(R,C,t) :- roomba(R,C-1,t-1), move(D,t), dir(D), D=r.

% Auxiliary (action attributes)

% Inertia

% Action generation
1 { move(D,t) : dir(D) } 1. % :- available(D,R,C), roomba(R,C).

#program check(t).

% Covered tiles and robot on goal.
%covered(R,C) :- tile(R,C,T), row(R), column(C), type(T), T=free.

:- query(t), not goal(t).
goal(t) :- tile(R,C,goal), roomba(R,C,t).
#show move/2.    % We only show performed actions
%#show available/3.
#show roomba/3.