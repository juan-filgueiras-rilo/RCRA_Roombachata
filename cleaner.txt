#include <incmode>.
		 
#program base.
#const r=4.
#const c=8.
% Type declarations
% D={u,d,l,r}.
% move(D,T).
row(0..r).
column(0..c).
type(obs;free;goal;initial;actual).
dir(up;down;left;right).
% tile(R,C,T), row(R), column(C), type(T).
available(D,R,C) :- tile(R,C,_), tile(R2,C2,T), R-R2=1, D=up, T!=obs.
available(D,R,C) :- tile(R,C,_), tile(R2,C2,T), R2-R=1, D=down, T!=obs.
available(D,R,C) :- tile(R,C,_), tile(R2,C2,T), C-C2=1, D=left, T!=obs.
available(D,R,C) :- tile(R,C,_), tile(R2,C2,T), C2-C=1, D=right, T!=obs.

% Initial state
tile(1,1,initial).
tile(1,2,free).
tile(1,3,free).
tile(1,4,free).
tile(1,5,free).
tile(1,6,obs).
tile(1,7,obs).
tile(1,8,free).

tile(2,1,free).
tile(2,2,free).
tile(2,3,free).
tile(2,4,free).
tile(2,5,free).
tile(2,6,free).
tile(2,7,free).
tile(2,8,free).

tile(3,1,free).
tile(3,2,free).
tile(3,3,obs).
tile(3,4,obs).
tile(3,5,obs).
tile(3,6,free).
tile(3,7,free).
tile(3,8,free).

tile(4,1,free).
tile(4,2,free).
tile(4,3,free).
tile(4,4,obs).
tile(4,5,obs).
tile(4,6,free).
tile(4,7,free).
tile(4,8,goal).

roomba(R,C) :- tile(R,C,initial).

#program step(t).

% Executability axioms
%:- move(D,t,R,C), -available(D,R,C).

% Effect axioms
%:- move(D,t), not available(D).
% Auxiliary (action attributes)

% Inertia

% Action generation
% 1 {move(X,Y,t) : number(X),number(Y) } 1.
1 { move(D,t) : dir(D) } 1.

#program check(t).

% Covered tiles and robot on goal.
%covered(R,C) :- tile(R,C,T), row(R), column(C), type(T), T=free.

%:- query(t), not goal(t).
goal(t) :- goal(R,C), .
#show move/2.    % We only show performed actions
%#show available/3.
%#show roomba/2.