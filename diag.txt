time(0..pathlength).
step(0..pathlength-1).
switch(s1;s2).
component(r;b).
#show o/2.

fluent(r_active).
fluent(b_on).
fluent(b_prot).
fluent(closed(S)) :- switch(S).
fluent(ab(C)):-component(C).

agent(close(s1)).
exog(break).
exog(surge).
action(Y):-exog(Y).
action(Y):-agent(Y).

% Inertia (boolean fluents)
 h(F,I+1) :-  h(F,I), not -h(F,I+1), step(I), fluent(F).
-h(F,I+1) :- -h(F,I), not  h(F,I+1), step(I), fluent(F).

% Direct effects
h(closed(s1),I+1) :- o(close(s1),I), step(I).

% Indirect effects
 h(r_active,J) :- h(closed(s1),J), -h(ab(r),J), time(J).
-h(r_active,J) :- -h(closed(s1),J), time(J).
-h(r_active,J) :- h(ab(r),J), time(J).
 h(closed(s2),J) :- h(r_active,J), time(J).
 h(b_on,J) :-  h(closed(s2),J), -h(ab(b),J), time(J).
-h(b_on,J) :- -h(closed(s2),J), time(J).
-h(b_on,J) :- h(ab(b),J), time(J).

% Executability
:- o(close(S),J), h(closed(S),J), time(J).

% Malfunctioning
h(ab(b),I+1) :- o(break,I), step(I).
h(ab(r),I+1) :- o(surge,I), step(I).
h(ab(b),I+1) :- o(surge,I), not h(b_prot,I), step(I).

% Something happening actually occurs
o(A,I) :- hpd(A,I), step(I).

% Check that observations hold
:- obs(F,J), not h(F,J), time(J).
:- -obs(F,J), not -h(F,J), time(J).

% Completing the initial state
1 {h(F,0); -h(F,0)} 1 :- fluent(F).

% A history
hpd(close(s1),0).
-obs(closed(s1),0).
-obs(closed(s2),0).
obs(b_prot,0).
-obs(ab(b),0).
-obs(ab(r),0).
% Something went wrong
-obs(b_on,1).

% Diagnostic module: generate exogenous actions
{ o(Z,I):exog(Z) } :- step(I).

:~ o(Z,I), exog(Z), step(I). [1]

